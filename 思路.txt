思路: 传统社团划分的模块度，可以理解为 每一个社区内部节点的度除以总边数 记作QM
我们引入了一个关于的关系类别的模块度QR，定义为 每两个社团关系向量的距离减去对应的平均距离

若社团内存在边，我们将每一种边的属性作为关系向量的一维






experiment_community_detection.py和experiment_community_detection2.py
这两个实现 pandas下的社团划分，但是花费时间太长，所以用numpy重新写文件

experiment_community_detection3.py 即上述所说的重新写的文件
但是时间优化的还不够，需要对数据进行数字化，减少部分操作的时间复杂度
(预计: 部分操作的时间复杂度会从O(n)降到O(1)，
但是估计还不够，需要对算法或数据结构再进行详细的规划)

experiment_community_detection4.py
思路:
    1. 使用数据数字化.py将community_2.csv转化为community_2_index.csv
    2. 修改experiment_community_detection3.py中的代码，以满足community_2_index.csv

优化:
    1. 想想如何newman的思路对接，将QR也变成dq
    2. 优化数据结构，将存储的时间降低

问题：
    1. 边不能重复(比如, 第一个:(1, 2, 3) 第二个:(1, 3, 3) 最后保存的是(1,3,3))
    (428,圆明园[清代著名皇家园林],地点,北京  432,圆明园[清代著名皇家园林],标签,北京
     在测试集中, 上面两个数据发生冲突)
    2. 速度还不够快(多进程, 从240s降到12s)



名义师兄之前提到了带边类型的社团划分
设计了一个社团划分（领域划分）的算法
通过边的信息和传统社团划分相结合的方法，已达到划分的目的

运用类比想到可以通过边的信息和传统社团划分相结合来划分领域
传统的社团划分的想法是社团内连接多，社团间的连接少
迁移到我们的领域划分就是
领域内同类关系（边的属性）多，领域间同类关系少

于是做了一个实验
之前我手动筛选出了两个社团 旅游和食物
提取它们中关系，发现只有个别的是重合的，有比较明显的差异

所以我们基于传统社团划分的模块度QM提出了关于关系类别的模块度QR

QM 所有连接到领域i的边数量
每个领域边的数量加和/总边数
QR = 求和

最终模块度定义为……

我先简单的说下关于关系类别的模块度的计算
假设有两个点大龙湫和五大夫松，分别为社团i和j，关系类别有……这三个
所以定义它们的关系向量Ci和Cj分别（000）（000）
因为一开始每个点都是一个社团，不存在边，所以值全为0

len(c) 表示关系向量数，每次社团划分都会合并其中的两个社团

讲思路，k个点 取最大值Q




















